'a	input.sml	/^  type 'a susp = unit -> 'a$/;"	t
'a	input.sml	/^  type 'a susp$/;"	t
Change	input.sml	/^exception Change$/;"	e
Circular	input.sml	/^	  exception Circular$/;"	e
Factorial	input.sml	/^exception Factorial$/;"	e
Impossible	input.sml	/^          exception Impossible$/;"	e
Matcher	input.sml	/^functor Matcher (structure RegExp : REGEXP) :> MATCHER = struct$/;"	c
RegExp	input.sml	/^    structure RegExp = RegExp$/;"	r
RegExp	input.sml	/^functor Matcher (structure RegExp : REGEXP) :> MATCHER = struct$/;"	r
SUSP	input.sml	/^signature SUSP = sig$/;"	s
Susp	input.sml	/^structure Susp :> SUSP = struct$/;"	r
abstype_name	input.sml	/^abstype abstype_name$/;"	t
checked_factorial	input.sml	/^    fun checked_factorial n =$/;"	f
checked_factorial	input.sml	/^fun checked_factorial n =$/;"	f
delay	input.sml	/^  fun delay (t : 'a susp) =$/;"	f
delay	input.sml	/^  val delay : (unit -> 'a) -> 'a susp$/;"	v
dist	input.sml	/^fun dist (x:real, y:real):real = sqrt (x*x + y*y)$/;"	f
dist	input.sml	/^val dist : real * real -> real = fn (x:real, y:real) => sqrt (x*x + y*y)$/;"	v
fact	input.sml	/^    fun fact 0 = 1$/;"	f
force	input.sml	/^  fun force t = t ()$/;"	f
force	input.sml	/^  val force : 'a susp -> 'a$/;"	v
hyperlink	input.sml	/^type hyperlink = { protocol : string, address : string, display : string }$/;"	t
loopback	input.sml	/^  fun loopback f =$/;"	f
match	input.sml	/^    fun match regexp string =$/;"	f
match_is	input.sml	/^    fun match_is Zero cs k = false$/;"	f
memo	input.sml	/^          val memo : 'a susp ref = ref (fn () => raise Impossible)$/;"	v
r	input.sml	/^	  val r = ref (fn () => raise Circular)$/;"	v
r	input.sml	/^              let val r = t () in memo := (fn () => r); r end$/;"	v
suit	input.sml	/^datatype suit = Spades | Hearts | Diamonds | Clubs$/;"	t
t	input.sml	/^	  fun t () = force (!r)$/;"	f
t'	input.sml	/^          fun t' () =$/;"	f
